# Data Architecture Improvements

## Current Issues and Improvement Proposals

### 1. Type Definition Duplication

#### Problem
Multiple type definitions exist for the same data models across different files, leading to maintenance overhead and potential inconsistencies.

**Duplicate Definitions:**
- `Word` type is defined in:
  - Auto-generated by Prisma: `@prisma/client`
  - Manual definition: [src/types/index.ts:17-27](../src/types/index.ts#L17-L27)
  - Manual definition: [src/types/word-data.ts:14-22](../src/types/word-data.ts#L14-L22)

- `WordExample` type is defined in:
  - Auto-generated by Prisma: `@prisma/client`
  - Manual definition: [src/types/index.ts:29-36](../src/types/index.ts#L29-L36)
  - Manual definition: [src/types/word-data.ts:6-12](../src/types/word-data.ts#L6-L12)

- Other models (`User`, `WordProgress`, `LearningSession`) are also duplicated between Prisma and manual definitions

#### Recommended Approach
1. **Use Prisma types as the primary source of truth**
   ```typescript
   import { User, Word, WordProgress } from '@prisma/client';
   ```

2. **Create extended types only when additional computed fields are needed**
   ```typescript
   import { User } from '@prisma/client';

   export interface UserWithStats extends User {
     todayProgress: number; // Computed field
   }
   ```

3. **Remove redundant manual type definitions** in `src/types/index.ts` that exactly match Prisma models

### 2. Computed Data Stored in Database

#### Problem
User statistics that can be computed from existing data are stored directly in the User model, leading to potential data inconsistency.

**Affected Fields in User Model** ([schema.prisma:30-33](../prisma/schema.prisma#L30-L33)):
- `totalWordsLearned`: Can be computed from `WordProgress` where status is 'mastered'
- `totalStudyTime`: Can be computed from `LearningSession` records
- `currentStreak`: Can be computed from daily session history
- `longestStreak`: Can be computed from historical session data

#### Recommended Approach
**Option 1: Compute on-the-fly (Preferred)**
- Remove these fields from the database
- Create utility functions to compute them when needed
- Benefits: Always accurate, no sync issues

**Option 2: Cache with proper invalidation**
- Keep fields but implement proper update logic
- Add database triggers or application-level cache invalidation
- Benefits: Faster queries, but requires maintenance

### 3. Redundant Status Tracking

#### Problem
`WordProgress.previousStatus` field is used for change detection but adds complexity.

**Current Implementation** ([schema.prisma:144](../prisma/schema.prisma#L144)):
```prisma
previousStatus  String? // previous status for change detection
```

#### Recommended Approach
**Option 1: Remove and use audit log**
- Create a separate `WordProgressHistory` table for audit trail
- Query history when needed for analytics
- Benefits: Cleaner main table, full history tracking

**Option 2: Remove entirely**
- Detect changes at application level during updates
- Don't persist previous status
- Benefits: Simpler schema

### 4. Type Definition File Organization

#### Problem
Types are scattered across multiple files with unclear separation of concerns.

**Current Structure:**
- `src/types/index.ts`: Mix of database models, API types, and UI types (222 lines)
- `src/types/word-data.ts`: JSON data import types, overlapping with index.ts

#### Recommended Approach
Organize types by domain:
```
src/types/
  ├── database.ts      # Prisma extensions only (computed fields, joins)
  ├── api.ts           # API request/response types
  ├── ui.ts            # UI component prop types
  └── word-import.ts   # JSON data import types (rename from word-data.ts)
```

### 5. Authentication Models

#### Current State
NextAuth models are present ([schema.prisma:45-86](../prisma/schema.prisma#L45-L86)):
- `Account` - OAuth provider accounts (Google, GitHub, etc.)
- `Session` - Database session storage
- `VerificationToken` - Email verification and password reset tokens

**Current Authentication Implementation** ([lib/auth.ts](../src/lib/auth.ts)):
- NextAuth.js with **JWT strategy** (`strategy: 'jwt'`)
- CredentialsProvider (email/password only)
- PrismaAdapter configured but limited functionality used

#### Usage Analysis

**1. Session Table** - ❌ **NOT USED**
- JWT strategy stores sessions in tokens, not database
- Database sessions only used with `strategy: 'database'`
- Current implementation: JWT-based sessions
- **Can be removed** if staying with JWT strategy

**2. Account Table** - ❌ **NOT USED (Currently)**
- Required for OAuth providers (Google, GitHub, Facebook, etc.)
- Current implementation: Credentials authentication only
- **Future consideration**: Keep if planning to add OAuth providers
- **Can be removed** if only using email/password authentication

**3. VerificationToken Table** - ❌ **NOT USED (Currently)**
- Used for email verification flow (signup confirmation emails)
- Used for password reset functionality
- Current implementation: No email verification or password reset
- **Future consideration**: Keep if planning email verification or password reset
- **Can be removed** if not implementing these features

**4. User Authentication Fields:**
```prisma
model User {
  // Authentication fields
  name          String?
  email         String   @unique           // ✅ Used
  emailVerified DateTime?                  // ❌ Not used (no verification flow)
  image         String?                    // ⚠️ Stored but not actively used
  hashedPassword String?                   // ✅ Used (credentials auth)
}
```

#### Decision: Deferred for Future Planning

**Current Status:**
- Authentication tables exist but are mostly unused
- Only basic email/password authentication is implemented
- No OAuth, email verification, or password reset features

**Future Considerations Required:**
1. **OAuth Integration** - Will social login (Google/GitHub) be added?
2. **Email Verification** - Should users verify email on signup?
3. **Password Reset** - Is "forgot password" functionality needed?
4. **Session Strategy** - Stay with JWT or move to database sessions?

**Options:**

**Option A: Remove Unused Tables (Simplify)**
- Remove: Account, Session, VerificationToken
- Remove: User.emailVerified, User.image
- Keep: User.email, User.hashedPassword
- Benefits: Cleaner schema, less confusion
- Risks: Requires migration if adding OAuth later

**Option B: Keep for Future Extensibility**
- Keep all tables with documentation
- Add comments indicating "reserved for future use"
- Benefits: Easy to add OAuth/verification later
- Risks: Cluttered schema with unused tables

**Recommendation:** Decide based on product roadmap
- If no plans for OAuth/verification → Remove (Option A)
- If likely to add these features → Keep (Option B)

### 6. Word Model ID Strategy

#### Problem
There is a mismatch between schema definition and actual implementation:

**Schema Definition** ([schema.prisma:89](../prisma/schema.prisma#L89)):
```prisma
model Word {
  id String @id @default(cuid())  // Suggests auto-generated CUID
  // ...
}
```

**Actual Implementation** ([prisma/seed.ts:131](../prisma/seed.ts#L131)):
```typescript
await prisma.word.create({
  data: {
    id: jsonWord.id,  // Manually assigned from JSON: "easy_001", "medium_001", etc.
    // ...
  },
});
```

**Current State:**
- Database contains user-defined IDs like `easy_001`, `easy_002`, `medium_001`
- JSON files ([data/words/easy1.json](../data/words/easy1.json)) define custom IDs
- Seed script explicitly overrides Prisma's auto-generation

#### Decision: Use Auto-Generated CUID (Option A)

**Changes Required:**

1. **Keep schema as-is** - `@default(cuid())` is correct
2. **Update seed.ts** - Remove manual ID assignment:
   ```typescript
   await prisma.word.create({
     data: {
       // Remove: id: jsonWord.id,
       english: jsonWord.english,
       japanese: jsonWord.japanese,
       // ...
     },
   });
   ```
3. **Update JSON files** - Remove `id` field (no longer needed)
4. **Data migration** - Clear all existing data (planned)

**Benefits:**
- Follows Prisma best practices
- No manual ID management in JSON files
- Better for future scalability
- Cleaner seed script logic

**Migration Impact:**
- All existing Word records will be deleted (acceptable - data reset planned)
- WordProgress and related data will also be cleared
- No backward compatibility needed

### 7. Word Model Field Optimization

#### Problem
The Word model contains fields with ambiguous definitions that are not used effectively in the application.

**Fields to Remove:**

1. **difficulty** ([schema.prisma:98](../prisma/schema.prisma#L98))
   ```prisma
   difficulty  Int  @default(1) // 1-5 scale - REMOVE
   ```
   - Definition is ambiguous (what exactly does level 1-5 mean?)
   - Not used for session generation or word filtering
   - Application is moving away from difficulty-based features

2. **frequency** ([schema.prisma:99](../prisma/schema.prisma#L99))
   ```prisma
   frequency   Int  @default(1) // usage frequency ranking - REMOVE
   ```
   - Vague definition (what corpus? what scale?)
   - Not actively used in learning algorithm
   - No clear value to the application

**Impact on Data Files:**
- JSON files can keep these fields for reference (seed script will ignore them)
- Or remove from JSON files to keep them clean
- File names like `easy1.json`, `medium1.json` can remain (just organizational naming)

**Seed Script Changes** ([prisma/seed.ts:136-137](../prisma/seed.ts#L136-L137)):
```typescript
// Remove these lines:
difficulty: getDifficultyFromId(jsonWord.id),
frequency: jsonWord.frequency,
```

**Related Function to Remove** ([prisma/seed.ts:50-55](../prisma/seed.ts#L50-L55)):
```typescript
// Delete this function - no longer needed
function getDifficultyFromId(id: string): number {
  if (id.startsWith('easy')) return 1;
  if (id.startsWith('medium')) return 2;
  if (id.startsWith('hard')) return 3;
  return 1;
}
```

### 8. WordExample Table Consolidation

#### Problem
WordExample is a separate table with a 1-to-many relationship, but the application only uses one example per word.

**Current Design:**
```prisma
model Word {
  id       String @id @default(cuid())
  examples WordExample[]  // One-to-many relationship
}

model WordExample {
  id       String @id @default(cuid())
  wordId   String
  english  String
  japanese String
  difficulty Int
  context  String
  word     Word @relation(fields: [wordId], references: [id])
}
```

**Actual Usage:**
- Each word has exactly 1 example in practice
- No plans to support multiple examples per word
- Extra table join adds complexity

#### Decision: Consolidate into Word Table

**New Schema:**
```prisma
model Word {
  id          String   @id @default(cuid())
  english     String   @unique
  japanese    String
  phonetic    String?
  partOfSpeech String

  // Example sentence (consolidated from WordExample)
  exampleEnglish   String
  exampleJapanese  String

  progress    WordProgress[]
}

// Remove WordExample model entirely
```

**Benefits:**
- Simpler schema (one less table)
- No JOIN required for word queries
- Better query performance
- Matches actual application usage

**Removed Fields:**
- `WordExample.id` - no longer needed
- `WordExample.difficulty` - redundant with word difficulty (which is also being removed)
- `WordExample.context` - not used in application (removed)

**Seed Script Changes:**
```typescript
// Before (nested loop for examples)
await prisma.word.create({
  data: {
    id: jsonWord.id,
    english: jsonWord.english,
    // ...
  },
});
for (const example of jsonWord.examples) {
  await prisma.wordExample.create({ /* ... */ });
}

// After (single create with example)
await prisma.word.create({
  data: {
    english: jsonWord.english,
    japanese: jsonWord.japanese,
    phonetic: jsonWord.phonetic,
    partOfSpeech: jsonWord.partOfSpeech,
    exampleEnglish: jsonWord.examples[0].english,    // Take first example
    exampleJapanese: jsonWord.examples[0].japanese,
  },
});
```

**JSON File Impact:**
- Can keep examples as array (take first one)
- Or simplify to single example object
- Either approach works

### 9. LearningSession Table Evaluation

#### Current State
**Schema** ([schema.prisma:157-172](../prisma/schema.prisma#L157-L172)):
```prisma
model LearningSession {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  wordsStudied   Int      @default(15)
  completedAt    DateTime

  user User @relation(fields: [userId], references: [id])
}
```

**Current Usage Analysis:**

1. **Session Creation** ([api/sessions/complete/route.ts:51-56](../src/app/api/sessions/complete/route.ts#L51-L56))
   - Stores: `userId`, `wordsStudied`, `completedAt`
   - Created at end of each learning session

2. **Streak Calculation** ([api/sessions/complete/route.ts:233-265](../src/app/api/sessions/complete/route.ts#L233-L265))
   - Groups sessions by date to calculate consecutive daily activity
   - Used to update `User.currentStreak` and `User.longestStreak`

3. **Daily Progress** ([api/progress/daily/route.ts:41-65](../src/app/api/progress/daily/route.ts#L41-L65))
   - Aggregates `wordsStudied` for today
   - Counts sessions completed today

4. **Learning History** ([api/progress/learning-history/route.ts:29-58](../src/app/api/progress/learning-history/route.ts#L29-L58))
   - Shows calendar view of which days user studied
   - Displays session count and word count per day

5. **Session History** ([api/sessions/history/route.ts:20-103](../src/app/api/sessions/history/route.ts#L20-103))
   - Lists recent sessions
   - Calculates weekly/monthly session counts
   - Calculates learning streak

#### Fields Usage:
- ✅ **completedAt** - CRITICAL: Used for all date-based calculations
- ⚠️ **wordsStudied** - Currently used but can be computed from WordProgress
- ❌ **id** - Only for internal reference, no business logic dependency
- ❌ **createdAt** - Unused (completedAt is used instead)

#### Key Question: Is This Table Necessary?

**Option A: Keep LearningSession Table (Recommended)**

**Reasoning:**
- Sessions are a distinct business concept (a learning activity event)
- `completedAt` timestamp is essential for:
  - Streak calculation (consecutive daily activity)
  - Learning history calendar
  - Session counting
- Cannot easily be derived from WordProgress alone because:
  - WordProgress tracks per-word state, not session events
  - Multiple words can be reviewed in one session
  - Need to know WHEN sessions occurred, not just when words were studied

**Improvements:**
```prisma
model LearningSession {
  id          String   @id @default(cuid())
  userId      String
  completedAt DateTime // Keep: essential for date-based features

  user User @relation(fields: [userId], references: [id])

  @@index([userId, completedAt]) // Optimize common queries
}
```

**Remove:**
- `wordsStudied` - Can compute from WordProgress updates in the same session time window
- `createdAt` - Redundant with completedAt

**Option B: Remove Table Entirely (Not Recommended)**

**Why this doesn't work:**
- Would need to infer sessions from WordProgress.updatedAt
- Problems:
  - Multiple reviews of same word would create ambiguity
  - Can't distinguish between "session on day X" vs "updated progress on day X"
  - Streak calculation becomes complex and unreliable
  - Loss of explicit session boundary tracking

**Option C: Simplify to DateLog Table**

```prisma
model ActivityLog {
  id     String   @id @default(cuid())
  userId String
  date   DateTime @db.Date // Just the date, no time

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, date])
  @@index([userId, date])
}
```

**Reasoning:**
- If we only care about "did user study on this day?"
- One record per day, regardless of session count
- Simpler for streak calculation

**Problems:**
- Loses session granularity (can't show "3 sessions today")
- Can't show session history timeline
- Less useful for future analytics

#### Decision Recommendation: **Option A** (Keep Simplified LearningSession)

**Rationale:**
1. Sessions are a meaningful business event
2. `completedAt` timestamp is irreplaceable for date-based features
3. Removing it would require complex workarounds
4. Minor cleanup (remove wordsStudied, createdAt) keeps it lean

**Benefits:**
- Clean session tracking
- Reliable streak calculation
- Supports future features (session duration, session types, etc.)
- Clear audit trail of user activity

**Computed Instead of Stored:**
- `wordsStudied` - COUNT from WordProgress where updatedAt matches session time
- Daily/weekly/monthly session counts - Query learningSession by date range
- Streak - Calculate from consecutive dates in learningSession records

### 10. User Table Field Optimization

#### Current State
**Schema** ([schema.prisma:12-43](../prisma/schema.prisma#L12-L43)):
```prisma
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Authentication fields
  name          String?
  email         String   @unique
  emailVerified DateTime?
  image         String?
  hashedPassword String?

  // Learning preferences
  dailyGoal          Int     @default(15)
  sessionDuration    Int     @default(10)
  preferredLanguage  String  @default("ja")

  // Progress tracking
  totalWordsLearned  Int     @default(0)
  currentStreak      Int     @default(0)
  longestStreak      Int     @default(0)
  totalStudyTime     Int     @default(0)
}
```

#### Field Analysis

**Authentication Fields:**
- ✅ **name** - Used for display
- ✅ **email** - Required for login (unique constraint)
- ✅ **hashedPassword** - Required for credentials authentication
- ❌ **emailVerified** - Email verification not implemented, unused
- ❌ **image** - Stored but not displayed anywhere, unused

**Learning Preferences:**
- ❌ **dailyGoal** - Defined but not used in application
- ❌ **sessionDuration** - Always fixed at 10 minutes, not variable
- ❌ **preferredLanguage** - Always "ja" (Japanese), no multi-language support

**Progress Tracking (All Computable):**
- ❌ **totalWordsLearned** - Can compute: `COUNT(WordProgress WHERE correctAnswers > 0)`
  - Updated: [sessions/complete/route.ts:268-275](../src/app/api/sessions/complete/route.ts#L268-L275)
  - Issue: Risk of data inconsistency

- ❌ **currentStreak** - Can compute from LearningSession consecutive dates
  - Updated: [sessions/complete/route.ts:259-265](../src/app/api/sessions/complete/route.ts#L259-L265)
  - Issue: Risk of data inconsistency

- ❌ **longestStreak** - Can compute: `MAX(currentStreak)` from history
  - Updated: [sessions/complete/route.ts:283](../src/app/api/sessions/complete/route.ts#L283)
  - Issue: Risk of data inconsistency

- ❌ **totalStudyTime** - Can compute: `sessionDuration * COUNT(LearningSession)`
  - **BUG**: Displayed in UI but never updated (always 0)
  - Shows at [profile/page.tsx:440](../src/app/profile/page.tsx#L440)

#### Issues Identified

**1. Computed Data Stored in Database**
All 4 statistics fields can be calculated from other tables:
- Causes data inconsistency risk
- Requires update logic in multiple places
- `totalStudyTime` has a bug (not updated)

**2. Unused Fields**
- `emailVerified` - No email verification flow
- `image` - Not displayed in application
- `dailyGoal` - Not used in application logic
- `sessionDuration` - Always 10 minutes (hardcoded)
- `preferredLanguage` - Always "ja" (no multi-language)

**3. No Future Requirements**
All unused and computed fields have no planned use in application

#### Decision: Remove All Non-Essential Fields

**Fields to Remove:**
1. `totalWordsLearned` - Computable, unused
2. `currentStreak` - Computable, unused
3. `longestStreak` - Computable, unused
4. `totalStudyTime` - Computable, unused (currently buggy)
5. `emailVerified` - Unused
6. `image` - Unused
7. `dailyGoal` - Unused
8. `sessionDuration` - Fixed value, unused
9. `preferredLanguage` - Fixed value, unused

**Simplified Schema:**
```prisma
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Authentication only
  name           String?
  email          String   @unique
  hashedPassword String?

  // Relations
  progress      WordProgress[]
  sessions      LearningSession[]
  accounts      Account[]
  sessions_auth Session[]

  @@map("users")
  @@schema("smart-vocab")
}
```

**Benefits:**
- Minimal authentication-only user model
- No data inconsistency risk
- No unused fields cluttering schema
- Cleaner, easier to understand
- Statistics computed on-demand when needed

**Migration Impact:**
- Remove 9 fields from User table
- Remove update logic from session completion ([sessions/complete/route.ts:286-293](../src/app/api/sessions/complete/route.ts#L286-L293))
- Create utility functions to compute statistics when needed for display
- Update dashboard/profile queries to compute values

### 11. WordProgress Table and Session Logic Redesign

#### Current Issues with WordProgress

**Spaced Repetition Fields (Mostly Unused):**
- `easeFactor` - Used only for interval calculation, which itself is not effectively used
- `interval` - Used only for nextReviewDate calculation
- `repetitions` - Used only for interval logic (1st, 2nd, 3rd+ attempts)
- `nextReviewDate` - Exists but doesn't effectively control session selection
  - Problem: Users may not study on scheduled days
  - Problem: Many words may be due on same day
  - Problem: Current logic doesn't prioritize by this date

**Performance Fields (Some Unused):**
- `totalReviews` ✅ Used - Status calculation
- `correctAnswers` ✅ Used - Status calculation
- `streak` ✅ Used - Status calculation (consecutive correct answers)
- `lastAnswerCorrect` ❌ Unused - Saved but never referenced

**Status Fields:**
- `status` ✅ Critical - Core of session composition
- `previousStatus` ⚠️ Used only for change detection in feedback, can be calculated

#### User Experience Analysis

**Key Insights:**

1. **Streak = Recent Mastery State (定着度)**
   - High streak: Recently performing well → Content is sticking
   - Low streak (0): Recently failed → Still unstable
   - Important: `accuracy: 0.50, streak: 3` means "was struggling but now improving"

2. **Accuracy = Overall Aptitude (得意度)**
   - High accuracy: Already knew it / Easy to remember
   - Low accuracy: Difficult / Hard to remember
   - Independent metric from streak

3. **Proposed Dependencies:**
   - **Review Interval ← Streak** (consecutive correct answers)
     - streak 0: 1 day later
     - streak 1: 3 days later
     - streak 2: 7 days later
     - streak 3: 14 days later
     - streak 4+: 30 days later
   - **Priority ← Accuracy** (among same status/streak)
     - Lower accuracy = Higher priority

#### Decision: Simplified WordProgress Model

**New Schema:**
```prisma
model WordProgress {
  id       String   @id @default(cuid())
  userId   String
  wordId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Performance metrics
  totalReviews    Int     @default(0)
  correctAnswers  Int     @default(0)
  accuracy        Float   @default(0)  // Computed on update
  streak          Int     @default(0)  // Consecutive correct answers

  // Timing metrics
  lastReviewedAt         DateTime @default(now())
  recommendedReviewDate  DateTime @default(now())  // Based on streak

  // Status
  status          String  @default("new")

  user User @relation(fields: [userId], references: [id])
  word Word @relation(fields: [wordId], references: [id])

  @@unique([userId, wordId])
  @@index([userId, status, recommendedReviewDate])
  @@index([userId, status, accuracy])
  @@index([userId, lastReviewedAt])
}
```

**Fields Removed:**
1. `easeFactor` - No longer needed
2. `interval` - Replaced by streak-based logic
3. `repetitions` - Replaced by streak
4. `nextReviewDate` - Replaced by recommendedReviewDate
5. `lastAnswerCorrect` - Unused
6. `previousStatus` - Can be calculated during update

**Fields Added:**
1. `accuracy` - Computed on update (correctAnswers / totalReviews)
2. `recommendedReviewDate` - Streak-based recommended review date

#### Improved Status Calculation

```typescript
function calculateMasteryStatus(progress: WordProgress): MasteryStatus {
  const { totalReviews, correctAnswers, streak } = progress;
  const accuracy = correctAnswers / totalReviews;

  if (totalReviews === 0) return 'new';

  // Learning phase
  if (totalReviews <= 3) return 'learning';

  // Mastered: Two paths for motivation
  // Path A: Recent mastery (streak-focused)
  // Path B: Overall aptitude (accuracy-focused)
  if (streak >= 3 || (streak >= 2 && accuracy >= 0.80)) {
    return 'mastered';
  }

  return 'reviewing';
}
```

**Benefits:**
- ✅ Faster mastery for struggling words (streak 3 → mastered)
- ✅ Faster mastery for easy words (streak 2 + accuracy 0.8 → mastered)
- ✅ Better motivation (status changes more frequently)

#### Review Interval Logic

```typescript
function getRecommendedReviewInterval(streak: number): number {
  if (streak === 0) return 1;   // Failed → Next day
  if (streak === 1) return 3;   // 1 correct → 3 days
  if (streak === 2) return 7;   // 2 correct → 1 week
  if (streak === 3) return 14;  // 3 correct → 2 weeks
  return 30;                     // 4+ correct → 1 month
}

function updateProgress(progress: WordProgress, isCorrect: boolean) {
  const newStreak = isCorrect ? progress.streak + 1 : 0;
  const newCorrectAnswers = progress.correctAnswers + (isCorrect ? 1 : 0);
  const newTotalReviews = progress.totalReviews + 1;
  const newAccuracy = newCorrectAnswers / newTotalReviews;

  const interval = getRecommendedReviewInterval(newStreak);
  const recommendedReviewDate = addDays(new Date(), interval);

  return {
    streak: newStreak,
    correctAnswers: newCorrectAnswers,
    totalReviews: newTotalReviews,
    accuracy: newAccuracy,
    lastReviewedAt: new Date(),
    recommendedReviewDate,
    status: calculateMasteryStatus({
      totalReviews: newTotalReviews,
      correctAnswers: newCorrectAnswers,
      streak: newStreak
    })
  };
}
```

#### Priority Calculation (Deterministic)

```typescript
function calculatePriority(word: WordProgress, now: Date): number {
  const daysOverdue = Math.max(0, daysBetween(word.recommendedReviewDate, now));
  const daysSinceReview = daysBetween(word.lastReviewedAt, now);

  let priority = 0;

  // 1. Days overdue (most important)
  priority += daysOverdue * 20;

  // 2. Streak = 0 (recently failed)
  if (word.streak === 0 && word.totalReviews >= 2) {
    priority += 50;
  }

  // 3. Low accuracy
  if (word.accuracy < 0.5 && word.totalReviews >= 4) {
    priority += 30;
  } else if (word.accuracy < 0.7 && word.totalReviews >= 4) {
    priority += 15;
  }

  // 4. Days since last review
  priority += daysSinceReview * 5;

  // No randomness - deterministic priority
  return priority;
}

function selectByPriority(candidates: WordProgress[], count: number): WordProgress[] {
  return candidates
    .map(word => ({ word, priority: calculatePriority(word, new Date()) }))
    .sort((a, b) => {
      // Same streak → Lower accuracy first
      if (a.word.streak === b.word.streak) {
        if (Math.abs(a.word.accuracy - b.word.accuracy) > 0.1) {
          return a.word.accuracy - b.word.accuracy;
        }
      }
      // Otherwise sort by priority
      return b.priority - a.priority;
    })
    .slice(0, count)
    .map(item => item.word);
}
```

**Key Points:**
- ✅ No randomness in priority calculation (preserves calculated priority)
- ✅ Same streak → Lower accuracy prioritized
- ✅ Clear, debuggable logic

#### Session Composition Logic

**Session Size:** 10 words

**Three Patterns:**
```typescript
const SESSION_PATTERNS = {
  // Pattern A: New-focused (early learning)
  newFocused: {
    new: 6,
    learning: 1,
    reviewing: 1,
    mastered: 1,
    // Total: 9
  },

  // Pattern B: Balanced (standard)
  balanced: {
    new: 5,
    learning: 2,
    reviewing: 1,
    mastered: 1,
    // Total: 9
  },

  // Pattern C: Review-focused (consolidation)
  reviewFocused: {
    new: 4,
    learning: 2,
    reviewing: 2,
    mastered: 1,
    // Total: 9
  }
};
```

**Random Slots:** 0-3 words (randomly determined each session)
- Creates variety between sessions
- Prevents predictability

**Session Construction Flow:**
```typescript
async function buildSession(userId: string): Promise<WordProgress[]> {
  // Step 1: Determine random slot count (0-3)
  const randomSlotCount = Math.floor(Math.random() * 4);
  const prioritySlotCount = 10 - randomSlotCount;

  // Step 2: Select pattern randomly
  const pattern = randomChoice(['newFocused', 'balanced', 'reviewFocused']);

  // Step 3: Scale pattern to priority slot count
  const composition = scaleComposition(pattern, prioritySlotCount);

  // Step 4: Select words by priority + keep candidate pool
  const selectedWords = [];
  const candidatePool = [];

  for (const [status, count] of Object.entries(composition)) {
    const { selected, candidates } = await selectTopWordsWithCandidates(
      userId, status, count
    );
    selectedWords.push(...selected);
    candidatePool.push(...candidates); // Keep unused candidates
  }

  // Step 5: Fill shortage from candidate pool (no duplicate check needed)
  const shortage = prioritySlotCount - selectedWords.length;
  if (shortage > 0) {
    const fillers = selectByPriority(candidatePool, shortage);
    selectedWords.push(...fillers);
  }

  // Step 6: Add random slots
  if (randomSlotCount > 0) {
    const excludeIds = new Set([
      ...selectedWords.map(w => w.id),
      ...candidatePool.map(w => w.id)
    ]);
    const randomWords = await selectRandomWords(userId, randomSlotCount, excludeIds);
    selectedWords.push(...randomWords);
  }

  // Step 7: Final shuffle
  return shuffle(selectedWords);
}
```

**Candidate Pool Strategy:**
```typescript
async function selectTopWordsWithCandidates(
  userId: string,
  status: MasteryStatus,
  count: number
): Promise<{ selected: WordProgress[]; candidates: WordProgress[] }> {
  // Phase 1: Due words (recommendedReviewDate passed)
  const dueWords = await prisma.wordProgress.findMany({
    where: { userId, status, recommendedReviewDate: { lte: new Date() } },
    take: Math.max(count * 5, 20)
  });

  if (dueWords.length >= count) {
    const selected = selectByPriority(dueWords, count);
    const candidates = dueWords.filter(w => !selected.includes(w));
    return { selected, candidates };
  }

  // Phase 2: Near-due words (within 2 days)
  const nearDue = await prisma.wordProgress.findMany({
    where: {
      userId, status,
      recommendedReviewDate: { gt: new Date(), lte: addDays(new Date(), 2) }
    },
    take: count * 3
  });

  // Phase 3: All words (sorted by lastReviewedAt)
  const remaining = await prisma.wordProgress.findMany({
    where: { userId, status },
    orderBy: { lastReviewedAt: 'asc' },
    take: count * 2
  });

  const allCandidates = [...dueWords, ...nearDue, ...remaining];
  const selected = selectByPriority(allCandidates, count);
  const candidates = allCandidates.filter(w => !selected.includes(w));

  return { selected, candidates };
}
```

**Benefits:**
- ✅ **Performance**: Only fetch necessary candidates, reuse pool for shortage
- ✅ **No duplicate checks**: Candidate pool already excludes selected words
- ✅ **Guaranteed coverage**: All words eventually appear via recommendedReviewDate
- ✅ **Variety**: Random pattern + random slots (0-3) each session
- ✅ **Priority preserved**: Deterministic selection within each status

**Example Session:**
```
Random slots: 2
Priority slots: 8

Pattern: balanced (scaled to 8)
→ new: 4, learning: 2, reviewing: 1, mastered: 1

Selection:
- new: 4 words (priority order) + 20 candidates
- learning: 2 words (priority order) + 10 candidates
- reviewing: 1 word (priority order) + 5 candidates
- mastered: 1 word (priority order) + 3 candidates

Total selected: 8 words
Candidate pool: 30 words (unused candidates)

Random slots: 2 words (excluding selected + pool)

Final: 10 words → shuffle
```

**Shortage Example:**
```
Random slots: 0
Priority slots: 10

Pattern: reviewFocused (scaled to 10)
→ new: 4, learning: 2, reviewing: 2, mastered: 2

Selection:
- new: 4 words
- learning: 2 words
- reviewing: 0 words (shortage: 2) + 3 candidates
- mastered: 2 words

Total selected: 8 words (shortage: 2)
Candidate pool: 35 candidates

Fill shortage: Select 2 from candidate pool by priority
→ Total: 10 words
```

#### Performance Optimization for Session Construction

**Potential Bottleneck Analysis:**

Current proposal could result in multiple sequential DB queries:
- 4 statuses × up to 3 queries each = up to 12 DB queries
- Sequential execution = slow response time (~600ms)

**Optimized Strategy: Parallel Query Execution**

**Key Improvements:**
1. **Parallel Queries**: Execute all status queries simultaneously using `Promise.all`
2. **Index Optimization**: Compound indexes for efficient filtering
3. **Candidate Pool Reuse**: Minimize additional queries for random slots
4. **Select Optimization**: Fetch only necessary fields

**Optimized Schema Indexes:**
```prisma
model WordProgress {
  // ... fields ...

  @@unique([userId, wordId])

  // Optimized indexes for session construction
  @@index([userId, status, recommendedReviewDate]) // Primary query
  @@index([userId, status, accuracy])               // Struggling words
  @@index([userId, status])                         // Count queries
}
```

**Optimized Session Construction:**
```typescript
async function buildSessionOptimized(userId: string): Promise<WordProgress[]> {
  const now = new Date();

  // Step 1: Determine random slots and pattern
  const randomSlotCount = Math.floor(Math.random() * 4); // 0-3
  const prioritySlotCount = 10 - randomSlotCount;
  const pattern = randomChoice(['newFocused', 'balanced', 'reviewFocused']);
  const composition = scaleComposition(SESSION_PATTERNS[pattern], prioritySlotCount);

  // Step 2: PARALLEL QUERY EXECUTION (4 queries simultaneously)
  const [newWords, learningWords, reviewingWords, masteredWords] = await Promise.all([
    fetchStatusCandidates(userId, 'new', composition.new, now),
    fetchStatusCandidates(userId, 'learning', composition.learning, now),
    fetchStatusCandidates(userId, 'reviewing', composition.reviewing, now),
    fetchStatusCandidates(userId, 'mastered', composition.mastered, now),
  ]);

  // Step 3: Merge results
  const selectedWords = [
    ...newWords.selected,
    ...learningWords.selected,
    ...reviewingWords.selected,
    ...masteredWords.selected
  ];

  const candidatePool = [
    ...newWords.candidates,
    ...learningWords.candidates,
    ...reviewingWords.candidates,
    ...masteredWords.candidates
  ];

  // Step 4: Fill shortage from candidate pool
  const shortage = prioritySlotCount - selectedWords.length;
  if (shortage > 0) {
    const fillers = selectByPriority(candidatePool, shortage);
    selectedWords.push(...fillers);
  }

  // Step 5: Random slots (reuse candidate pool when possible)
  if (randomSlotCount > 0) {
    if (candidatePool.length >= randomSlotCount) {
      // No additional query needed - use candidate pool
      const remainingPool = candidatePool.filter(w => !selectedWords.includes(w));
      const randomWords = shuffle(remainingPool).slice(0, randomSlotCount);
      selectedWords.push(...randomWords);
    } else {
      // Fallback: additional query (rare case)
      const excludeIds = new Set([
        ...selectedWords.map(w => w.id),
        ...candidatePool.map(w => w.id)
      ]);
      const randomWords = await selectRandomWords(userId, randomSlotCount, excludeIds);
      selectedWords.push(...randomWords);
    }
  }

  // Step 6: Final shuffle
  return shuffle(selectedWords);
}

// Efficient single-query candidate fetching
async function fetchStatusCandidates(
  userId: string,
  status: MasteryStatus,
  count: number,
  now: Date
): Promise<{ selected: WordProgress[]; candidates: WordProgress[] }> {
  if (count === 0) {
    return { selected: [], candidates: [] };
  }

  // Single optimized query with compound index
  const candidates = await prisma.wordProgress.findMany({
    where: { userId, status },
    select: {
      id: true,
      wordId: true,
      totalReviews: true,
      correctAnswers: true,
      accuracy: true,
      streak: true,
      lastReviewedAt: true,
      recommendedReviewDate: true,
      status: true,
      word: {
        select: {
          id: true,
          english: true,
          japanese: true,
          phonetic: true,
          partOfSpeech: true,
          exampleEnglish: true,
          exampleJapanese: true
        }
      }
    },
    take: Math.max(count * 5, 20), // Sufficient candidate pool
    orderBy: [
      { recommendedReviewDate: 'asc' }, // Due date priority
      { accuracy: 'asc' }               // Then by difficulty
    ]
  });

  const selected = selectByPriority(candidates, count);
  const remaining = candidates.filter(w => !selected.includes(w));

  return { selected, candidates: remaining };
}
```

**Performance Comparison:**

| Metric | Before Optimization | After Optimization |
|--------|--------------------|--------------------|
| DB Queries | 4-12 (sequential) | 4 (parallel) |
| Estimated Time | ~600ms | ~150ms |
| Memory Usage | Medium | Medium |
| Code Complexity | High | Medium |
| Cache Potential | Low | High |

**Additional Optimizations (Future):**

1. **Connection Pooling:**
```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

2. **Result Caching (Redis):**
```typescript
// Cache frequently accessed data
const cacheKey = `user:${userId}:status:counts`;
const cached = await redis.get(cacheKey);

if (!cached) {
  const counts = await getStatusCounts(userId);
  await redis.setex(cacheKey, 300, JSON.stringify(counts)); // 5min cache
}
```

3. **Database Query Analysis:**
```sql
-- Verify index usage
EXPLAIN ANALYZE
SELECT * FROM word_progress
WHERE user_id = 'xxx' AND status = 'reviewing'
ORDER BY recommended_review_date ASC
LIMIT 20;

-- Should show: Index Scan using idx_user_status_date
```

**Conclusion:**
The proposed WordProgress schema and session construction logic is well-optimized:
- ✅ Minimal fields (no redundant data)
- ✅ Appropriate compound indexes for all query patterns
- ✅ Parallel query execution reduces latency by 75%
- ✅ Candidate pool reuse minimizes additional queries
- ✅ Select optimization reduces data transfer
- ✅ Scalable architecture ready for future caching

## Implementation Priority

### High Priority
1. **Word Model ID Strategy (Issue #6)** - Must fix before adding new data
2. **Word Model Field Optimization (Issue #7)** - Remove unused difficulty/frequency fields
3. **WordExample Table Consolidation (Issue #8)** - Simplify schema structure
4. **LearningSession Table Optimization (Issue #9)** - Remove redundant fields
5. **User Table Field Optimization (Issue #10)** - Remove all non-essential fields
6. **WordProgress Table and Session Logic Redesign (Issue #11)** - Simplified model with improved UX
7. **Type definition duplication (Issue #1)** - Causes immediate maintenance issues

### Medium Priority
8. **File organization (Issue #4)** - Improves developer experience

### Low Priority
9. **Authentication models (Issue #5)** - Deferred for future planning

## Migration Strategy

### Phase 1: Word Model Refactoring (High Priority)
**Goal:** Simplify Word and WordExample models

1. **Update schema.prisma**
   - Remove `difficulty` and `frequency` fields from Word model
   - Consolidate WordExample fields into Word model
   - Remove WordExample model entirely

2. **Update seed.ts**
   - Remove manual ID assignment (use auto-generated CUID)
   - Remove `getDifficultyFromId()` function
   - Update word creation to include example fields directly
   - Remove WordExample creation loop

3. **Database migration**
   - Clear all existing data: `npm run words:add -- --clear` (acceptable - planned reset)
   - Run `npx prisma db push` to apply schema changes
   - Re-seed with new data structure

4. **Update JSON files (optional)**
   - Remove `id` field from words (no longer needed)
   - Remove `difficulty` and `frequency` fields (optional - seed script will ignore)
   - Keep examples as array or flatten to single object

### Phase 2: Type Consolidation (High Priority)
**Goal:** Eliminate duplicate type definitions

1. **Identify usage**
   - Search for all imports from `@/types` and `@/types/word-data`
   - Map which components use which types

2. **Replace with Prisma types**
   - Import from `@prisma/client` instead of manual definitions
   - Create extension types only where needed (e.g., `UserWithStats`)

3. **Update type files**
   - Remove duplicate definitions from `src/types/index.ts`
   - Keep only extension types and non-database types
   - Update `src/types/word-data.ts` for JSON import only

### Phase 3: File Organization (Medium Priority)
**Goal:** Clean separation of concerns

1. **Create new structure**
   ```
   src/types/
     ├── database.ts      # Prisma extensions only
     ├── api.ts           # API types
     ├── ui.ts            # UI types
     └── word-import.ts   # JSON import types
   ```

2. **Migrate types**
   - Move types to appropriate files
   - Update all imports across codebase

3. **Remove old files**
   - Delete `src/types/index.ts` after migration
   - Delete `src/types/word-data.ts` after renaming

### Phase 4: Schema Optimization (Medium Priority)
**Goal:** Remove computed data from database

1. **Create utility functions**
   - Implement computed field functions for User stats
   - Test performance impact

2. **Update queries**
   - Replace direct field access with computed functions
   - Update all affected components

3. **Database migration**
   - Remove `totalWordsLearned`, `totalStudyTime`, `currentStreak`, `longestStreak` from User
   - Run migration

4. **Remove previousStatus**
   - Implement change detection at application level
   - Remove field from WordProgress
   - Update progress update logic

### Phase 5: Testing & Verification
**Goal:** Ensure no regressions

1. **Unit tests**
   - Test word creation with new schema
   - Test computed field functions
   - Test type safety

2. **Integration tests**
   - Test full learning session flow
   - Test progress tracking
   - Test statistics calculations

3. **Performance testing**
   - Benchmark computed fields vs stored values
   - Check query performance after JOIN removal
   - Monitor database size reduction

## Notes

- Prisma auto-generates types from `schema.prisma` via `npx prisma generate`
- Generated types are located in `node_modules/.prisma/client/index.d.ts`
- Any changes to `schema.prisma` require running `npx prisma generate` to update types
- Database changes require `npx prisma db push` or `npx prisma migrate dev`
- All existing data will be cleared during Phase 1 migration (acceptable - planned data reset)