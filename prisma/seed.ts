import { PrismaClient } from '@prisma/client';
import path from 'path';
import fs from 'fs';

const prisma = new PrismaClient();

// Command line options
const args = process.argv.slice(2);
const forceUpdate = args.includes('--force');
const verbose = args.includes('--verbose');
const clearAll = args.includes('--clear');

// Legacy JSON structure (backward compatibility)
interface LegacyJsonWordExample {
  id?: string;
  english: string;
  japanese: string;
  difficulty?: number;
  context?: string;
}

interface LegacyJsonWord {
  id?: string;
  english: string;
  japanese: string;
  phonetic?: string;
  partOfSpeech: string;
  frequency?: number;
  examples?: LegacyJsonWordExample[];
}

// New JSON structure (recommended)
interface NewJsonWord {
  english: string;
  japanese: string;
  phonetic?: string;
  partOfSpeech: string;
  exampleEnglish: string;
  exampleJapanese: string;
}

// Unified type that handles both formats
type JsonWord = LegacyJsonWord | NewJsonWord;

// Helper to extract example from JSON word (handles both formats)
function getExampleFromWord(word: JsonWord): { english: string; japanese: string } {
  // New format: direct fields
  if ('exampleEnglish' in word && 'exampleJapanese' in word) {
    return {
      english: word.exampleEnglish,
      japanese: word.exampleJapanese,
    };
  }
  // Legacy format: examples array
  if ('examples' in word && word.examples && word.examples.length > 0) {
    return {
      english: word.examples[0].english,
      japanese: word.examples[0].japanese,
    };
  }
  // Fallback
  return { english: '', japanese: '' };
}

async function loadJsonData(): Promise<JsonWord[]> {
  const allWords: JsonWord[] = [];
  const dataDir = path.join(process.cwd(), 'data', 'words');
  
  // Load data from all JSON files
  const files = ['wordsJson.json'];
  
  for (const file of files) {
    const filePath = path.join(dataDir, file);
    if (fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      const words: JsonWord[] = JSON.parse(fileContent);
      allWords.push(...words);
    }
  }
  
  return allWords;
}


async function main() {
  console.log('ðŸ“š Starting word data management...');
  
  if (clearAll) {
    console.log('ðŸš¨ Clear mode: Will delete ALL existing word data and start fresh');
  } else if (forceUpdate) {
    console.log('âš ï¸  Force update mode: Will update existing word data');
  }
  
  try {
    // Load JSON data
    const jsonWords = await loadJsonData();
    console.log(`ðŸ“– Loaded ${jsonWords.length} words from JSON files`);
    
    if (jsonWords.length === 0) {
      console.log('â„¹ï¸  No word data found in JSON files. Nothing to process.');
      return;
    }
    
    // Handle clear mode - delete all existing data
    if (clearAll) {
      console.log('ðŸ§¹ Clearing all existing word data...');
      await clearAllWordData();
      console.log('âœ¨ All existing word data has been cleared');
      
      // Add all words as new
      console.log('ðŸ“ Adding all words as new data...');
      await addAllWordsAsNew(jsonWords);
      console.log('âœ… Word data management completed successfully!');
      console.log(`ðŸ“Š Summary:`);
      console.log(`   - All previous data: CLEARED`);
      console.log(`   - New words added: ${jsonWords.length}`);
      console.log(`   - Total words in database: ${jsonWords.length}`);
      return;
    }
    
    // Check existing words in database (for normal mode)
    const existingWords = await prisma.word.findMany({
      select: { id: true, english: true }
    });
    const existingWordEnglish = new Set(existingWords.map(w => w.english));

    if (verbose) {
      console.log(`ðŸ“‹ Found ${existingWords.length} existing words in database`);
    }

    // Filter new words (not yet in database) - check by english field
    const newWords = jsonWords.filter(word => !existingWordEnglish.has(word.english));
    const existingNewWords = jsonWords.filter(word => existingWordEnglish.has(word.english));
    
    console.log(`âœ¨ New words to add: ${newWords.length}`);
    console.log(`â™»ï¸  Existing words (will skip): ${existingNewWords.length}`);
    
    if (forceUpdate && existingNewWords.length > 0) {
      console.log('ðŸ”„ Force update mode: Updating existing words...');
      await updateExistingWords(existingNewWords);
    }
    
    if (newWords.length === 0 && !forceUpdate) {
      console.log('âœ… All words already exist in database. Nothing to add.');
      return;
    }
    
    // Add new words
    console.log('ðŸ“ Adding new words...');
    let addedWords = 0;

    for (const jsonWord of newWords) {
      try {
        const example = getExampleFromWord(jsonWord);
        // Create word with example (ID auto-generated by Prisma)
        await prisma.word.create({
          data: {
            english: jsonWord.english,
            japanese: jsonWord.japanese,
            phonetic: jsonWord.phonetic,
            partOfSpeech: jsonWord.partOfSpeech,
            exampleEnglish: example.english,
            exampleJapanese: example.japanese,
          },
        });
        addedWords++;

        if (verbose) {
          console.log(`  âœ“ Added word: ${jsonWord.english}`);
        }

      } catch (error) {
        console.error(`âŒ Error adding word ${jsonWord.english}:`, error);
      }
    }

    console.log('âœ… Word data management completed successfully!');
    console.log(`ðŸ“Š Summary:`);
    console.log(`   - New words added: ${addedWords}`);
    console.log(`   - Total words in database: ${existingWords.length + addedWords}`);
    
    if (forceUpdate) {
      const updatedWords = existingNewWords.length;
      console.log(`   - Updated existing words: ${updatedWords}`);
    }
    
  } catch (error) {
    console.error('âŒ Error during word data management:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

async function updateExistingWords(words: JsonWord[]) {
  let updatedWords = 0;

  for (const jsonWord of words) {
    try {
      const example = getExampleFromWord(jsonWord);
      // Update word data (find by english since we use auto-generated IDs)
      await prisma.word.update({
        where: { english: jsonWord.english },
        data: {
          japanese: jsonWord.japanese,
          phonetic: jsonWord.phonetic,
          partOfSpeech: jsonWord.partOfSpeech,
          exampleEnglish: example.english,
          exampleJapanese: example.japanese,
        },
      });
      updatedWords++;

      if (verbose) {
        console.log(`  ðŸ”„ Updated word: ${jsonWord.english}`);
      }

    } catch (error) {
      console.error(`âŒ Error updating word ${jsonWord.english}:`, error);
    }
  }

  console.log(`ðŸ”„ Updated ${updatedWords} existing words`);
}

async function clearAllWordData() {
  // Delete in order to respect foreign key constraints
  console.log('  ðŸ—‘ï¸  Deleting word progress data...');
  await prisma.wordProgress.deleteMany();

  console.log('  ðŸ—‘ï¸  Deleting learning sessions...');
  await prisma.learningSession.deleteMany();

  console.log('  ðŸ—‘ï¸  Deleting words...');
  await prisma.word.deleteMany();

  console.log('  âœ… All word-related data cleared');
}

async function addAllWordsAsNew(jsonWords: JsonWord[]) {
  let addedWords = 0;

  for (const jsonWord of jsonWords) {
    try {
      const example = getExampleFromWord(jsonWord);
      // Create word with example (ID auto-generated by Prisma)
      await prisma.word.create({
        data: {
          english: jsonWord.english,
          japanese: jsonWord.japanese,
          phonetic: jsonWord.phonetic,
          partOfSpeech: jsonWord.partOfSpeech,
          exampleEnglish: example.english,
          exampleJapanese: example.japanese,
        },
      });
      addedWords++;

      if (verbose) {
        console.log(`  âœ“ Added word: ${jsonWord.english}`);
      }

    } catch (error) {
      console.error(`âŒ Error adding word ${jsonWord.english}:`, error);
    }
  }

  console.log(`âœ… Added ${addedWords} words`);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });